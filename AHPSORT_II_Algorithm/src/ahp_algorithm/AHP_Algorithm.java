/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ahp_algorithm;


import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;
import org.apache.commons.math3.linear.EigenDecomposition;
import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealVector;

/**
 *
 * @author Sergio
 */
public class AHP_Algorithm extends javax.swing.JFrame {
    
    //ATRIBUTOS
    private AHP_Interface interfaz;
    private ArrayList<String> alternativas, criterios;
    private ArrayList<ArrayList<Double>> matriz_c_c, matriz_a_c;
    private ArrayList<ArrayList<ArrayList<Double>>> vector_matrices_a_c;
    private Integer contador_pasos;
    private ArrayList<Double> pesosCriterios;
    private Double CI, CR;
    private ArrayList<Double> v_CI, v_CR;
    private RealVector autoVector;
    private Double[] CR_SAATY = {0.58, 0.9, 1.12, 1.24, 1.32, 1.41, 1.45, 1.49}; 
    private Boolean ComparadosCriterios = false;
    
    
    //DATOS ESTÁTICOS
    ArrayList<ArrayList<ArrayList<Double>>> criterios_prioridades_locales = new ArrayList<>();
        //CRITERIO 1
    private Double[] vector_RPs_CPs_cr1 = {0.0, 20.0, 41.2, 100.0, 82.4, 160.0, 123.6, 164.8, 206.0 };
    private Double[] vector_prio_local_cr1 = {0.336, 0.277, 0.132, 0.058, 0.086, 0.029, 0.032, 0.026, 0.023};
        //CRITERIO 2
    private Double[] vector_RPs_CPs_cr2 = {0.0, 5000.0, 50914.4, 95000.0, 101828.8, 180000.0, 152743.2, 203657.6, 254573.0};
    private Double[] vector_prio_local_cr2 = {0.32, 0.261, 0.139, 0.075, 0.074, 0.032, 0.047, 0.031, 0.022};
        //CRITERIO 3
    private Double[] vector_RPs_CPs_cr3 = {0.0, 5000.0, 7025.4, 19000.0, 14050.8, 27000.0, 21076.2, 28101.6, 35127.0};
    private Double[] vector_prio_local_cr3 = {0.459, 0.138, 0.124, 0.063, 0.069, 0.04, 0.048, 0.034, 0.026};
        //CRITERIO 4
    private Double[] vector_RPs_CPs_cr4 = {0.0, 300.0, 764.8, 1800.0, 1529.6, 2500.0, 2294.4, 3059.2, 3824.0};
    private Double[] vector_prio_local_cr4 = {0.308, 0.259, 0.149, 0.066, 0.071, 0.034, 0.06, 0.032, 0.023};
        //CRITERIO 5
    private Double[] vector_RPs_CPs_cr5 = {0.00, 300.0, 321.6, 600.0, 643.2, 900.0, 964.8, 1286.4, 1608.0};
    private Double[] vector_prio_local_cr5 = {0.385, 0.262, 0.112, 0.07, 0.062, 0.035, 0.033, 0.023, 0.018};
    
    
    //Matriz de prioridades locales y globales 
    ArrayList<ArrayList<Double>> matriz_prioridades_locales_globales = new ArrayList<>();
    
    //ATRIBUTO FINAL
    private ArrayList<String> ranking_alternativas;
    
    /**
     * Creates new form AHP_Algorithm
     */
    public AHP_Algorithm() {
        matriz_a_c =  new ArrayList<>();
        matriz_c_c = new ArrayList<>();
        vector_matrices_a_c = new ArrayList<ArrayList<ArrayList<Double>>>();
        pesosCriterios = new ArrayList<>();
        ranking_alternativas = new ArrayList<>();
        contador_pasos = 0;
        CR = CI = -1.0;
        v_CI = new ArrayList<>();
        v_CR = new ArrayList<>();
        
        initComponents();
        jTable1.addMouseListener(new MouseAdapter() {
            public void mouseClicked(final MouseEvent e) {
                if (e.getClickCount() == 1) {
                    jTable1 = (JTable) e.getSource();
                    final int fila = jTable1.getSelectedRow();
                    final int columna = jTable1.getSelectedColumn();

                    final String urObjctInCell = (String) jTable1.getValueAt(fila, columna);
                    
                    if (jTable1.getValueAt(fila, columna) == null && jTable1.getValueAt(columna - 1, fila + 1) != null)
                        jTable1.setValueAt("1/" + jTable1.getValueAt(columna - 1, fila + 1), fila, columna);
                    
                }
            }
        }
        );
        generar_prioridadesLocales_criterios();
        
    }
    
    public void setAHP(AHP_Interface _interfaz, ArrayList<String> _alternativas, ArrayList<String> _criterios){
        interfaz = _interfaz;
        alternativas = _alternativas;
        criterios = _criterios;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        SIGUIENTE = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        SIGUIENTE.setText("SIGUIENTE");
        SIGUIENTE.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SIGUIENTEActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(165, Short.MAX_VALUE)
                .addComponent(SIGUIENTE, javax.swing.GroupLayout.PREFERRED_SIZE, 135, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(162, 162, 162))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(25, 25, 25)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(SIGUIENTE, javax.swing.GroupLayout.DEFAULT_SIZE, 52, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void SIGUIENTEActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SIGUIENTEActionPerformed
        // TODO add your handling code here:
        
        if (contador_pasos == 0){ //SE TIENE QUE RELLENAR LA MATRIZ DE COMPARACIÓN DE CRITERIOS
            v_CR.clear();
            ObtenerMatriz(matriz_c_c, criterios.size(), criterios.size());
            
            //Una vez termina de obtener la matriz, calcula el Wj.
            pesosCriterios = calcula_pesos_CI_CR(matriz_c_c,matriz_c_c.size(), matriz_c_c.size());
            obtener_prioridades_locales_globales(pesosCriterios);
            interfaz.setVisible(true);
            dispose();
            //generarMatriz(false, criterios.get(contador_pasos));
            contador_pasos++;
        }
        
        if (contador_pasos > 1){ //SE TIENE QUE RELLENAR EN BUCLE LAS MATRICES DE COMPARACIÓN DE TODAS LAS ALTERNATIVAS RESPECTO A UN CRITERIO
            matriz_a_c.clear();
            ObtenerMatriz(matriz_a_c, alternativas.size(), alternativas.size());
            vector_matrices_a_c.add((ArrayList<ArrayList<Double>>) matriz_a_c.clone());
            pesosCriterios = calcula_pesos_CI_CR(matriz_a_c,matriz_a_c.size(), matriz_a_c.size());
            
            if (contador_pasos <= criterios.size())
                generarMatriz(false, criterios.get(contador_pasos-1)); //SEGUIMOS AÑADIENDO RELACIONES DE PREFERENCIA ENTRE ALTERNATIVAS PARA UN CRITERIO...
            else{
                //YA SE HA TERMINADO TODAS LAS MATRICES A RELLENAR...TOCA CALCULAR 
                System.out.println("NºMatrices de comparaciones de alternativas resp. criterios : "+vector_matrices_a_c.size());
                System.out.println(vector_matrices_a_c);
                interfaz.set_visibilidad_relaciones(false);
                interfaz.setVisible(true);
                dispose();
                
            }
            contador_pasos++;          
        }
        
        else //PARA REAJUSTAR AL RITMO QUE SE HACE CLICK EN EL BUTTON.
            contador_pasos++;
    }//GEN-LAST:event_SIGUIENTEActionPerformed
    
    private void ObtenerMatriz(ArrayList<ArrayList<Double>> matriz, int filas, int columnas){
        ArrayList<Double> vector_aux = new ArrayList<>();
        Double a;
        for (int i = 0; i < filas; i++) {
            vector_aux = new ArrayList<>();
            for (int j = 1; j < columnas + 1; j++) {
                String e = jTable1.getValueAt(i, j).toString();
                if (e.contains("/")) {
                    String[] spl = e.split("/");
                    if (spl.length == 2){
                        Double n1 = Double.parseDouble(spl[0]);
                        Double n2 = Double.parseDouble(spl[1]);
                        a = (n1 / n2);
                    }else{
                        Double n1 = Double.parseDouble(spl[0]);
                        Double n2 = Double.parseDouble(spl[1]);
                        Double n3 = Double.parseDouble(spl[2]);
                        a = (n1 / (n2 / n3) );
                    }
                } 
                else
                    a = Double.parseDouble(e);
                vector_aux.add(a);
            }
           matriz.add(vector_aux);
        }
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(AHP_Algorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(AHP_Algorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(AHP_Algorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(AHP_Algorithm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AHP_Interface().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton SIGUIENTE;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables
    
    public void generarMatriz(boolean compara_criterios, String nombre_tabla) {
        
        if (compara_criterios) { //Comprobar si es para generar la matriz de comparación entre criterios.
            DefaultTableModel tabla_auxiliar = new DefaultTableModel();
            tabla_auxiliar.addColumn(nombre_tabla);

            for (int i = 0; i < criterios.size(); i++)
                tabla_auxiliar.addColumn(criterios.get(i));
            
            for (int i = 0; i < criterios.size(); i++) {
                tabla_auxiliar.addRow(new Object[criterios.size()]);
                tabla_auxiliar.setValueAt(criterios.get(i), i, 0);
            }
            for (int i = 0; i < tabla_auxiliar.getRowCount(); i++) {
                for (int j = 0; j < tabla_auxiliar.getColumnCount(); j++) {
                    if (i == j) {
                        tabla_auxiliar.setValueAt(1, i, j + 1);
                    }
                }
            }
            jTable1.setModel(tabla_auxiliar);
        } else { //Matriz de alternativas por cada uno de los criterios.
            
            DefaultTableModel tabla_auxiliar = new DefaultTableModel();
            tabla_auxiliar.addColumn(nombre_tabla);

            for (int i = 0; i < alternativas.size(); i++)
                tabla_auxiliar.addColumn(alternativas.get(i));
            
            for (int i = 0; i < alternativas.size(); i++) {
                tabla_auxiliar.addRow(new Object[alternativas.size()]);
                tabla_auxiliar.setValueAt(alternativas.get(i), i, 0);
            }
            for (int i = 0; i < tabla_auxiliar.getRowCount(); i++) {
                for (int j = 0; j < tabla_auxiliar.getColumnCount(); j++) {
                    if (i == j) {
                        tabla_auxiliar.setValueAt(1, i, j + 1);
                    }
                }
            }
            jTable1.setModel(tabla_auxiliar);
        }

    }
    
    public ArrayList<Double> getV_CR() {
        return v_CR;
    }
    
    public ArrayList<Double> getV_CI(){
        return v_CI;
    }
    
    private ArrayList<Double> calcula_pesos_CI_CR(ArrayList<ArrayList<Double>> matriz,int n_filas, int n_columnas){
    
        //OBTENER LOS AUTOVALORES DE LA MATRIZ.
        double[][] values = new double[n_filas][n_columnas];
        
        for (int i = 0; i < n_filas; i++)
            for (int j = 0; j < n_columnas; j++)
                values[i][j] = matriz.get(i).get(j);

        RealMatrix matrix = MatrixUtils.createRealMatrix(values);
        EigenDecomposition descomposition = new EigenDecomposition(matrix);
        double[] eigenValues = descomposition.getRealEigenvalues(); //Obtenemos los autovalores
        
        //CALCULAR CUÁL ES EL MÁXIMO AUTOVALOR.
        double maxAutoValor = -1.0;
        int indice_AV_max = -1;
        for (int i = 0; i < eigenValues.length; i++) {
            if (maxAutoValor < eigenValues[i]) {
                maxAutoValor = eigenValues[i];
                indice_AV_max = i;
            }
        }
        
        //AHORA SE OBTIENE EL ÍNDICE DE CONSISTENCIA, TRAS HABER OBTENIDO EL MÁXIMO AUTOVALOR.
        CI = (maxAutoValor - matriz.size()) / (matriz.size() - 1); //Fórmula del CI.
        
        
        //OBTENER EL AUTOVECTOR, A PARTIR DEL AUTOVALOR MÁXIMO OBTENIDO.
        autoVector = descomposition.getEigenvector(indice_AV_max);
        double[] _autoVector = autoVector.toArray();
        ArrayList<Double> vector_pesos = new ArrayList<>();
        for (int i = 0; i < _autoVector.length; i++) 
            vector_pesos.add(_autoVector[i]);
        
        //NORMALIZAR EL AUTOVECTOR. --> NO HABRÍA PORQUÉ NORMALIZARLO.
        ArrayList<Double> v_pesos_norm = normalizarPesos(vector_pesos);
        
        if (matriz.size() >= 3)
            CR = CI / CR_SAATY[matriz.size() - 3]; //SI ES MENOR QUE 3 --> NO PUEDE EXISTIR INCONSISTENCIA.
        System.out.println("CR = "+CR);
        System.out.println("VECTOR DE CRITERIOS = "+criterios);
        System.out.println("VECTOR DE PESOS = "+vector_pesos);
        v_CI.add(CI);
        v_CR.add(CR);
        return v_pesos_norm; //DEVOLVER EL VECTOR DE PESOS NORMALIZADOS.
    }
    
    private ArrayList<Double> normalizarPesos(ArrayList<Double> v_pesos) {
        Double sum = 0.0;
        for (int i = 0; i < v_pesos.size(); i++)
            sum += v_pesos.get(i);
        
        for (int i = 0; i < v_pesos.size(); i++)
            v_pesos.set(i, v_pesos.get(i) / sum);
        
        return v_pesos;
    }
    
    
    private void ordenarVectores(Double[] vector){
        Double aux;
        for (int i = 0; i < vector.length-1; i++) {
            for (int j = 0; j < vector.length; j++) {
                if (vector[i] > vector[j]){
                    aux = vector[i];
                    vector[i] = vector[j];
                    vector[j] = aux;
                }
            }
        }
    }
    
    
    //----------- PREPARACIÓN DE LAS TABLAS DE PRIORIDADES LOCALES PARA LOS CRITERIOS ------------
    
    private void generar_prioridadesLocales_criterios(){
        
        ArrayList<Double> v1 = new ArrayList<>();
        
        //CRITERIO 1
        criterios_prioridades_locales.add(new ArrayList<>());
        v1.clear(); v1.addAll(Arrays.asList(vector_RPs_CPs_cr1)); Collections.sort(v1);
        criterios_prioridades_locales.get(0).add(new ArrayList<>(v1)); //Añado espacio para el RP/CP.
        v1.clear(); v1.addAll(Arrays.asList(vector_prio_local_cr1)); Collections.sort(v1); Collections.reverse(v1);
        criterios_prioridades_locales.get(0).add(new ArrayList<>(v1)); //Añado espacio para el de Prioridades locales.
        
        ArrayList<Double> v2 = new ArrayList<>();
        //CRITERIO 2
        criterios_prioridades_locales.add(new ArrayList<>()); //Añado espacio al criterio (donde poner 2 vectores: RP/CP y el de Prioridades locales)
        v2.clear(); v2.addAll(Arrays.asList(vector_RPs_CPs_cr2)); Collections.sort(v2);
        criterios_prioridades_locales.get(1).add(new ArrayList<>(v2)); //Añado espacio para el RP/CP.
        v2.clear(); v2.addAll(Arrays.asList(vector_prio_local_cr2)); Collections.sort(v2); Collections.reverse(v2);
        criterios_prioridades_locales.get(1).add(new ArrayList<>(v2)); //Añado espacio para el de Prioridades locales.
        
        ArrayList<Double> v3 = new ArrayList<>();
        //CRITERIO 3
        criterios_prioridades_locales.add(new ArrayList<>()); //Añado espacio al criterio (donde poner 2 vectores: RP/CP y el de Prioridades locales)
        v3.clear(); v3.addAll(Arrays.asList(vector_RPs_CPs_cr3)); Collections.sort(v3);
        criterios_prioridades_locales.get(2).add(new ArrayList<>(v3)); //Añado espacio para el RP/CP.
        v3.clear(); v3.addAll(Arrays.asList(vector_prio_local_cr3)); Collections.sort(v3); Collections.reverse(v3);
        criterios_prioridades_locales.get(2).add(new ArrayList<>(v3)); //Añado espacio para el de Prioridades locales.
        
        ArrayList<Double> v4 = new ArrayList<>();
        //CRITERIO 4
        criterios_prioridades_locales.add(new ArrayList<>()); //Añado espacio al criterio (donde poner 2 vectores: RP/CP y el de Prioridades locales)
        v4.clear(); v4.addAll(Arrays.asList(vector_RPs_CPs_cr4)); Collections.sort(v4);
        criterios_prioridades_locales.get(3).add(new ArrayList<>(v4)); //Añado espacio para el RP/CP.
        v4.clear(); v4.addAll(Arrays.asList(vector_prio_local_cr4)); Collections.sort(v4); Collections.reverse(v4);
        criterios_prioridades_locales.get(3).add(new ArrayList<>(v4)); //Añado espacio para el de Prioridades locales.
        
        ArrayList<Double> v5 = new ArrayList<>();
        //CRITERIO 5
        criterios_prioridades_locales.add(new ArrayList<>()); //Añado espacio al criterio (donde poner 2 vectores: RP/CP y el de Prioridades locales)
        v5.clear(); v5.addAll(Arrays.asList(vector_RPs_CPs_cr5)); Collections.sort(v5);
        criterios_prioridades_locales.get(4).add(new ArrayList<>(v5)); //Añado espacio para el RP/CP.
        v5.clear(); v5.addAll(Arrays.asList(vector_prio_local_cr5)); Collections.sort(v5); Collections.reverse(v5);
        criterios_prioridades_locales.get(4).add(new ArrayList<>(v5)); //Añado espacio para el de Prioridades locales.
        
        System.out.println(criterios_prioridades_locales);
    }
    
    private void obtener_prioridades_locales_globales(ArrayList<Double> pesos_criterios){
        ArrayList<Double> v_1 = new ArrayList<>();
        Double[] v1 = {23.0, 17284.0, 2101.0, 387.0, 267.0, 0.0};
        v_1.clear(); v_1.addAll(Arrays.asList(v1));
        matriz_prioridades_locales_globales.add(v_1);
        
        ArrayList<Double> v_2 = new ArrayList<>();
        Double[] v2 = {61.0, 26571.0, 3945.0, 722.0, 818.0, 0.0};
        v_2.clear(); v_2.addAll(Arrays.asList(v2));
        matriz_prioridades_locales_globales.add(v_2);
        
        ArrayList<Double> v_3 = new ArrayList<>();
        Double[] v3 = {20.0, 14508.0, 1691.0, 219.0, 148.0, 0.0};
        v_3.clear(); v_3.addAll(Arrays.asList(v3));
        matriz_prioridades_locales_globales.add(v_3);
        
        ArrayList<Double> v_4 = new ArrayList<>();
        Double[] v4 = {32.0, 19139.0, 2299.0, 368.0, 622.0, 0.0};
        v_4.clear(); v_4.addAll(Arrays.asList(v4));
        matriz_prioridades_locales_globales.add(v_4);
        
        ArrayList<Double> v_5 = new ArrayList<>();
        Double[] v5 = {8.0, 11222.0, 1409.0, 156.0, 139.0, 0.0};
        v_5.clear(); v_5.addAll(Arrays.asList(v5));
        matriz_prioridades_locales_globales.add(v_5);
        
        ArrayList<Double> v_6 = new ArrayList<>();
        Double[] v6 = {17.0, 7548.0, 718.0, 175.0, 129.0, 0.0};
        v_6.clear(); v_6.addAll(Arrays.asList(v6));
        matriz_prioridades_locales_globales.add(v_6);
        
        ArrayList<Double> v_7 = new ArrayList<>();
        Double[] v7 = {58.0, 46137.0, 6377.0, 830.0, 934.0, 0.0};
        v_7.clear(); v_7.addAll(Arrays.asList(v7));
        matriz_prioridades_locales_globales.add(v_7);
        
        ArrayList<Double> v_8 = new ArrayList<>();
        Double[] v8 = {86.0, 52849.0, 9662.0, 716.0, 415.0, 0.0};
        v_8.clear(); v_8.addAll(Arrays.asList(v8));
        matriz_prioridades_locales_globales.add(v_8);
        
        
        boolean salir = false;
        double sum_prio_localesXpesos_crit;
        //RELLENAR TABLA DE PRIORIDADES LOCALES Y GLOBALES. --> REUTILIZAR LA MATRIZ ANTERIOR.
        for (int i = 0; i < matriz_prioridades_locales_globales.size(); i++) { //Primero recorre la Alternativa...
            sum_prio_localesXpesos_crit = 0.0;
            for (int j = 0; j < matriz_prioridades_locales_globales.get(i).size(); j++) { //Segundo recorre cada valor de esa alternativa para el criterio j...
                salir = false;
                if (j < matriz_prioridades_locales_globales.get(i).size() - 1){
                    for (int l = 0; l < criterios_prioridades_locales.get(j).get(0).size() && !salir; l++) { //
                        if (matriz_prioridades_locales_globales.get(i).get(j) < criterios_prioridades_locales.get(j).get(0).get(l)){ //Ha encontrado 1 valor que es justo el mayor al valor de la alternativa para el criterio.
                            System.out.print(matriz_prioridades_locales_globales.get(i).get(j) +" -----> ");
                            matriz_prioridades_locales_globales.get(i).set(j,  criterios_prioridades_locales.get(j).get(1).get(l-1) + ( (criterios_prioridades_locales.get(j).get(1).get(l) - criterios_prioridades_locales.get(j).get(1).get(l-1)) / (criterios_prioridades_locales.get(j).get(0).get(l) - criterios_prioridades_locales.get(j).get(0).get(l-1))) * (matriz_prioridades_locales_globales.get(i).get(j) - criterios_prioridades_locales.get(j).get(0).get(l-1)));
                            sum_prio_localesXpesos_crit += matriz_prioridades_locales_globales.get(i).get(j) * pesos_criterios.get(j);
                            salir = true;
                            System.out.println(matriz_prioridades_locales_globales.get(i).get(j));
                        }
                    }
                }
                else{
                    //Una vez recorrido todo el proceso de la Alternativa "i" para todos los criterios ---> calculo su peso global y lo añado a la columna final.
                    matriz_prioridades_locales_globales.get(i).set(j, sum_prio_localesXpesos_crit);
                    System.out.println("Peso global de la alternativa "+i+" = "+matriz_prioridades_locales_globales.get(i).get(j));
                }
            }
        }
        
        System.out.println("Nº filas = "+matriz_prioridades_locales_globales.size()+" ::: Nºcolumnas = "+matriz_prioridades_locales_globales.get(0).size());
        System.out.println(matriz_prioridades_locales_globales);
    }
    
    //----------- MÉTODOS DE CLASIFICACIÓN A LA CLASE CORRESPONDIENTE ---------------
    
    
    
}
